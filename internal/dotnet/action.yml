name: Dotnet Build
description: Build/test/publish .NET com parametros e outputs para empacotamento.

inputs:
  working_directory:
    required: false
    default: "."
  dotnet_version:
    required: false
    default: ""
  dotnet_version_file:
    required: false
    default: ""
  project:
    required: false
    default: ""

  enable_nuget:
    required: false
    default: ""
  nuget_auth_mode:
    required: false
    default: "dotnet"
  nuget_config_path:
    required: false
    default: ""
  nuget_config_content:
    required: false
    default: ""
  nuget_source_url:
    required: false
    default: ""
  nuget_source_name:
    required: false
    default: "private"
  nuget_username:
    required: false
    default: "token"
  nuget_password:
    required: false
    default: ""
  nuget_sources:
    required: false
    default: ""
  nuget_sources_json:
    required: false
    default: ""
  nuget_locked_mode:
    required: false
    default: "false"
  nuget_ignore_failed_sources:
    required: false
    default: "false"
  nuget_interactive:
    required: false
    default: "false"
  nuget_packages_dir:
    required: false
    default: ""
  nuget_no_cache:
    required: false
    default: "false"
  restore:
    required: false
    default: "true"
  build:
    required: false
    default: "false"
  test:
    required: false
    default: "false"
  publish:
    required: false
    default: "true"
  configuration:
    required: false
    default: "Release"
  framework:
    required: false
    default: ""
  runtime:
    required: false
    default: ""
  self_contained:
    required: false
    default: "false"
  verbosity:
    required: false
    default: ""
  nologo:
    required: false
    default: "false"
  disable_parallel:
    required: false
    default: "false"
  msbuild_targets:
    required: false
    default: ""
  msbuild_properties:
    required: false
    default: ""
  publish_single_file:
    required: false
    default: "false"
  publish_trimmed:
    required: false
    default: "false"
  publish_ready_to_run:
    required: false
    default: "false"
  restore_args:
    required: false
    default: ""
  build_args:
    required: false
    default: ""
  test_args:
    required: false
    default: ""
  publish_args:
    required: false
    default: ""
  publish_dir:
    required: false
    default: "publish"
  publish_multi:
    required: false
    default: "false"
  projects:
    required: false
    default: ""
  projects_include:
    required: false
    default: ""
  projects_exclude:
    required: false
    default: ""

outputs:
  language_effective:
    value: ${{ steps.meta.outputs.language_effective }}
  build_ran:
    value: ${{ steps.meta.outputs.build_ran }}
  publish_dir:
    value: ${{ steps.meta.outputs.publish_dir }}
  package_paths_default:
    value: ${{ steps.meta.outputs.package_paths_default }}

runs:
  using: composite
  steps:
    - name: Setup .NET
      if: inputs.dotnet_version != '' || inputs.dotnet_version_file != ''
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ inputs.dotnet_version }}
        dotnet-version-file: ${{ inputs.dotnet_version_file }}

    - name: Setup NuGet auth (setup-dotnet)
      if: inputs.nuget_auth_mode == 'setup-dotnet' && inputs.nuget_source_url != '' && inputs.nuget_password != ''
      uses: actions/setup-dotnet@v4
      with:
        source-url: ${{ inputs.nuget_source_url }}
      env:
        NUGET_AUTH_TOKEN: ${{ inputs.nuget_password }}

    - name: Dotnet build/test/publish
      id: meta
      shell: pwsh
      working-directory: ${{ inputs.working_directory }}
      run: |
        $ErrorActionPreference = 'Stop'

        function IsTrue([string]$v) { return ($v ?? '').Trim().ToLowerInvariant() -eq 'true' }
        function IsSet([string]$v) { return -not [string]::IsNullOrWhiteSpace(($v ?? '').Trim()) }

        function Read-Lines([string]$text) {
          if (-not (IsSet $text)) { return @() }
          return @(
            $text -split "(`r`n|`n|`r)" |
              ForEach-Object { $_.Trim() } |
              Where-Object { $_ -ne '' }
          )
        }

        function Parse-Args([string]$text) {
          if (-not (IsSet $text)) { return @() }

          $lines = Read-Lines $text
          if ($lines.Count -gt 1) {
            return $lines
          }

          $s = $lines[0]
          $args = New-Object System.Collections.Generic.List[string]
          $current = New-Object System.Text.StringBuilder
          $inSingle = $false
          $inDouble = $false

          foreach ($ch in $s.ToCharArray()) {
            if ($ch -eq '"' -and -not $inSingle) { $inDouble = -not $inDouble; continue }
            if ($ch -eq "'" -and -not $inDouble) { $inSingle = -not $inSingle; continue }

            if (-not $inSingle -and -not $inDouble -and [char]::IsWhiteSpace($ch)) {
              if ($current.Length -gt 0) {
                $args.Add($current.ToString())
                $null = $current.Clear()
              }
              continue
            }

            [void]$current.Append($ch)
          }

          if ($current.Length -gt 0) { $args.Add($current.ToString()) }
          return $args.ToArray()
        }

        function Normalize-PathForMatch([string]$p) {
          return ($p ?? '').Replace('\','/').Trim()
        }

        function Match-AnyWildcard([string[]]$patterns, [string]$candidate) {
          if (-not $patterns -or $patterns.Count -eq 0) { return $false }
          foreach ($pat in $patterns) {
            $p = Normalize-PathForMatch $pat
            if (-not (IsSet $p)) { continue }
            $wp = New-Object System.Management.Automation.WildcardPattern($p, 'IgnoreCase')
            if ($wp.IsMatch($candidate)) { return $true }
          }
          return $false
        }

        function Normalize-MsbuildProperties([string]$text) {
          $props = New-Object System.Collections.Generic.List[string]
          foreach ($line in (Read-Lines $text)) {
            $l = $line.Trim()
            if ($l.StartsWith('/p:')) { $l = '-p:' + $l.Substring(3) }
            if ($l.StartsWith('-p:')) { $props.Add($l); continue }
            if ($l -match '^[A-Za-z0-9_.-]+=(.*)$') { $props.Add("-p:$l"); continue }
            $props.Add($l)
          }
          return $props.ToArray()
        }

        function Run([string]$title, [ScriptBlock]$block) {
          Write-Host "::group::$title"
          & $block
          if ($LASTEXITCODE -ne 0) { throw "$title falhou com exit code $LASTEXITCODE" }
          Write-Host "::endgroup::"
        }

        $targetRaw = ('${{ inputs.project }}' ?? '').Trim()
        $target = if ([string]::IsNullOrWhiteSpace($targetRaw)) { '.' } else { $targetRaw }

        $restore = IsTrue '${{ inputs.restore }}'
        $build = IsTrue '${{ inputs.build }}'
        $test = IsTrue '${{ inputs.test }}'
        $publish = IsTrue '${{ inputs.publish }}'
        $ran = $restore -or $build -or $test -or $publish

        $configuration = ('${{ inputs.configuration }}' ?? '').Trim()
        $framework = ('${{ inputs.framework }}' ?? '').Trim()
        $runtime = ('${{ inputs.runtime }}' ?? '').Trim()
        $selfContained = ('${{ inputs.self_contained }}' ?? '').Trim().ToLowerInvariant()

        $verbosity = ('${{ inputs.verbosity }}' ?? '').Trim()
        $nologo = IsTrue '${{ inputs.nologo }}'
        $disableParallel = IsTrue '${{ inputs.disable_parallel }}'
        $msbuildTargets = ('${{ inputs.msbuild_targets }}' ?? '').Trim()
        $msbuildProps = Normalize-MsbuildProperties ('${{ inputs.msbuild_properties }}' ?? '')

        $restoreArgs = Parse-Args (('${{ inputs.restore_args }}' ?? '').Trim())
        $buildArgs = Parse-Args (('${{ inputs.build_args }}' ?? '').Trim())
        $testArgs = Parse-Args (('${{ inputs.test_args }}' ?? '').Trim())
        $publishArgs = Parse-Args (('${{ inputs.publish_args }}' ?? '').Trim())

        $publishDir = ('${{ inputs.publish_dir }}' ?? '').Trim()
        if ([string]::IsNullOrWhiteSpace($publishDir)) { $publishDir = 'publish' }

        $publishSingleFile = IsTrue '${{ inputs.publish_single_file }}'
        $publishTrimmed = IsTrue '${{ inputs.publish_trimmed }}'
        $publishReadyToRun = IsTrue '${{ inputs.publish_ready_to_run }}'

        $enableNugetRaw = ('${{ inputs.enable_nuget }}' ?? '').Trim()
        $nugetAuthMode = (('${{ inputs.nuget_auth_mode }}' ?? 'dotnet').Trim()).ToLowerInvariant()

        $nugetConfigPath = ('${{ inputs.nuget_config_path }}' ?? '').Trim()
        $nugetConfigContent = ('${{ inputs.nuget_config_content }}' ?? '')

        $nugetSourceUrl = ('${{ inputs.nuget_source_url }}' ?? '').Trim()
        $nugetSourceName = ('${{ inputs.nuget_source_name }}' ?? '').Trim()
        $nugetUsername = ('${{ inputs.nuget_username }}' ?? '').Trim()
        $nugetPassword = ('${{ inputs.nuget_password }}' ?? '').Trim()

        $nugetSourcesLegacyRaw = ('${{ inputs.nuget_sources }}' ?? '')
        $nugetSourcesJsonRaw = ('${{ inputs.nuget_sources_json }}' ?? '')

        $nugetLockedMode = IsTrue '${{ inputs.nuget_locked_mode }}'
        $nugetIgnoreFailedSources = IsTrue '${{ inputs.nuget_ignore_failed_sources }}'
        $nugetInteractive = IsTrue '${{ inputs.nuget_interactive }}'
        $nugetPackagesDir = ('${{ inputs.nuget_packages_dir }}' ?? '').Trim()
        $nugetNoCache = IsTrue '${{ inputs.nuget_no_cache }}'

        if (-not (IsSet $nugetSourceName)) { $nugetSourceName = 'private' }
        if (-not (IsSet $nugetUsername)) { $nugetUsername = 'token' }

        $nugetAuto = (IsSet $nugetConfigPath) -or (IsSet $nugetSourceUrl) -or (IsSet $nugetPassword) -or (IsSet $nugetSourcesLegacyRaw) -or (IsSet $nugetSourcesJsonRaw) -or (IsSet $nugetConfigContent)
        $enableNuget = if (-not (IsSet $enableNugetRaw)) { $nugetAuto } else { IsTrue $enableNugetRaw }

        if ($enableNuget -and $nugetAuthMode -notin @('dotnet','setup-dotnet','config')) {
          throw "nuget_auth_mode invalido: '$nugetAuthMode' (use dotnet|setup-dotnet|config)"
        }

        if ($enableNuget -and $nugetAuthMode -eq 'setup-dotnet') {
          if (-not (IsSet $nugetSourceUrl) -or -not (IsSet $nugetPassword)) {
            throw "nuget_auth_mode=setup-dotnet requer nuget_source_url e nuget_password."
          }
          if (IsSet $nugetConfigPath -or IsSet $nugetConfigContent) {
            throw "nuget_auth_mode=setup-dotnet nao deve ser usado junto com nuget_config_path/nuget_config_content (restore com --configfile ignora o config global)."
          }
          if (IsSet $nugetSourcesLegacyRaw -or IsSet $nugetSourcesJsonRaw) {
            throw "nuget_auth_mode=setup-dotnet suporta apenas um source (nuget_source_url). Remova nuget_sources/nuget_sources_json."
          }
        }

        $nugetConfigEffective = $null
        if (IsSet $nugetConfigContent) {
          $nugetConfigEffective = Join-Path $env:RUNNER_TEMP "veracode-build-helper-nuget.config"
          Set-Content -Path $nugetConfigEffective -Value $nugetConfigContent -Encoding UTF8
        } elseif (IsSet $nugetConfigPath) {
          if (-not (Test-Path $nugetConfigPath)) { throw "nuget_config_path nao encontrado: $nugetConfigPath" }
          $nugetConfigEffective = $nugetConfigPath
        }

        $sources = New-Object System.Collections.Generic.List[hashtable]

        if (IsSet $nugetSourcesJsonRaw) {
          try {
            $json = $nugetSourcesJsonRaw | ConvertFrom-Json
          } catch {
            throw "nuget_sources_json invalido (JSON). Dica: use um array de objetos [{\"name\":\"...\",\"url\":\"...\"}]."
          }
          if ($null -eq $json) { $json = @() }
          if ($json -isnot [System.Collections.IEnumerable]) { $json = @($json) }

          foreach ($item in $json) {
            $name = ($item.name ?? '').ToString().Trim()
            $url = ($item.url ?? '').ToString().Trim()
            $user = ($item.username ?? '').ToString().Trim()
            $pass = ($item.password ?? '').ToString()
            if (-not (IsSet $name)) { throw "nuget_sources_json: item com name vazio." }
            if (-not (IsSet $url)) { throw "nuget_sources_json: item '$name' com url vazia." }
            $sources.Add(@{ name = $name; url = $url; username = $user; password = $pass })
          }
        }

        if (IsSet $nugetSourcesLegacyRaw) {
          Write-Host "::warning::nuget_sources (name|url|...) esta obsoleto; prefira nuget_sources_json."
          foreach ($line in (Read-Lines $nugetSourcesLegacyRaw)) {
            $parts = $line.Split('|')
            if ($parts.Length -lt 2) { throw "Linha invalida em nuget_sources: '$line' (use name|url|username|password)" }
            $sName = ($parts[0] ?? '').Trim()
            $sUrl = ($parts[1] ?? '').Trim()
            $sUser = if ($parts.Length -ge 3) { ($parts[2] ?? '').Trim() } else { '' }
            $sPass = if ($parts.Length -ge 4) { ($parts[3] ?? '').Trim() } else { '' }
            if (-not (IsSet $sName)) { throw "nuget_sources: name vazio em '$line'" }
            if (-not (IsSet $sUrl)) { throw "nuget_sources: url vazia em '$line'" }
            $sources.Add(@{ name = $sName; url = $sUrl; username = $sUser; password = $sPass })
          }
        }

        if (IsSet $nugetSourceUrl) {
          $sources.Add(@{ name = $nugetSourceName; url = $nugetSourceUrl; username = $nugetUsername; password = $nugetPassword })
        }

        if ($enableNuget -and $nugetAuthMode -eq 'dotnet') {
          Run "nuget setup (dotnet)" {
            if (IsSet $nugetPassword) { Write-Host "::add-mask::$nugetPassword" }
            foreach ($src in $sources) {
              if (IsSet $src.password) { Write-Host "::add-mask::$($src.password)" }
            }

            if ($nugetConfigEffective) { Write-Host "NuGet config efetivo: $nugetConfigEffective" }
            if ($sources.Count -eq 0 -and -not $nugetConfigEffective) {
              Write-Host "enable_nuget ativo, mas nenhum source/config foi informado."
            }

            foreach ($src in $sources) {
              $args = @('nuget', 'update', 'source', $src.name, '--source', $src.url)
              if ($nugetConfigEffective) { $args += @('--configfile', $nugetConfigEffective) }
              if (IsSet $src.username -and IsSet $src.password) {
                $args += @('--username', $src.username, '--password', $src.password, '--store-password-in-clear-text')
              } elseif (IsSet $src.password -and -not (IsSet $src.username)) {
                throw "nuget_sources: password informado sem username para source '$($src.name)'."
              }

              & dotnet @args 2>$null
              if ($LASTEXITCODE -ne 0) {
                $args = @('nuget', 'add', 'source', $src.url, '--name', $src.name)
                if ($nugetConfigEffective) { $args += @('--configfile', $nugetConfigEffective) }
                if (IsSet $src.username -and IsSet $src.password) {
                  $args += @('--username', $src.username, '--password', $src.password, '--store-password-in-clear-text')
                }
                & dotnet @args
                if ($LASTEXITCODE -ne 0) { throw "Falha ao configurar nuget source '$($src.name)'." }
              }
              Write-Host "NuGet source ok: $($src.name)"
            }
          }
        }

        if ($enableNuget -and $nugetAuthMode -eq 'config' -and -not $nugetConfigEffective) {
          throw "nuget_auth_mode=config requer nuget_config_path ou nuget_config_content."
        }

        if ($restore) {
          Run "dotnet restore" {
            $args = @('restore', $target)
            if (IsSet $verbosity) { $args += @('--verbosity', $verbosity) }
            if ($nologo) { $args += '--nologo' }
            if ($disableParallel) { $args += '--disable-parallel' }
            if ($nugetConfigEffective) { $args += @('--configfile', $nugetConfigEffective) }
            if ($nugetLockedMode) { $args += '--locked-mode' }
            if ($nugetIgnoreFailedSources) { $args += '--ignore-failed-sources' }
            if ($nugetInteractive) { $args += '--interactive' }
            if (IsSet $nugetPackagesDir) { $args += @('--packages', $nugetPackagesDir) }
            if ($nugetNoCache) { $args += '--no-cache' }
            $args += $restoreArgs
            & dotnet @args
          }
        }

        if ($build) {
          Run "dotnet build" {
            $args = @('build', $target, '-c', $configuration)
            if ($restore) { $args += '--no-restore' }
            if (IsSet $verbosity) { $args += @('--verbosity', $verbosity) }
            if ($nologo) { $args += '--nologo' }
            if ($disableParallel) { $args += '--disable-parallel' }
            if (IsSet $framework) { $args += @('-f', $framework) }
            if (IsSet $msbuildTargets) { $args += @("-t:$msbuildTargets") }
            $args += $msbuildProps
            $args += $buildArgs
            & dotnet @args
          }
        }

        if ($test) {
          Run "dotnet test" {
            $args = @('test', $target, '-c', $configuration)
            if ($build) { $args += '--no-build' }
            if ($restore) { $args += '--no-restore' }
            if (IsSet $verbosity) { $args += @('--verbosity', $verbosity) }
            if ($nologo) { $args += '--nologo' }
            if ($disableParallel) { $args += '--disable-parallel' }
            if (IsSet $framework) { $args += @('-f', $framework) }
            if (IsSet $msbuildTargets) { $args += @("-t:$msbuildTargets") }
            $args += $msbuildProps
            $args += $testArgs
            & dotnet @args
          }
        }

        $publishMulti = IsTrue '${{ inputs.publish_multi }}'
        $explicitProjects = Read-Lines ('${{ inputs.projects }}' ?? '')
        $includePatterns = Read-Lines ('${{ inputs.projects_include }}' ?? '')
        $excludePatterns = Read-Lines ('${{ inputs.projects_exclude }}' ?? '')

        function Publish-One([string]$proj, [string]$outDir) {
          Run "dotnet publish: $proj" {
            $args = @('publish', $proj, '-c', $configuration, '-o', $outDir)
            if ($restore) { $args += '--no-restore' }
            if (IsSet $verbosity) { $args += @('--verbosity', $verbosity) }
            if ($nologo) { $args += '--nologo' }
            if (IsSet $framework) { $args += @('-f', $framework) }
            if (IsSet $runtime) { $args += @('-r', $runtime) }
            if (IsSet $selfContained) { $args += @('--self-contained', $selfContained) }
            if (IsSet $msbuildTargets) { $args += @("-t:$msbuildTargets") }
            if ($publishSingleFile) { $args += '-p:PublishSingleFile=true' }
            if ($publishTrimmed) { $args += '-p:PublishTrimmed=true' }
            if ($publishReadyToRun) { $args += '-p:PublishReadyToRun=true' }
            $args += $msbuildProps
            $args += $publishArgs
            & dotnet @args
          }
        }

        function Filter-Projects([string[]]$projects) {
          $out = New-Object System.Collections.Generic.List[string]
          foreach ($p in $projects) {
            $cand = Normalize-PathForMatch $p
            if (-not (IsSet $cand)) { continue }

            if ($includePatterns.Count -gt 0 -and -not (Match-AnyWildcard $includePatterns $cand)) { continue }
            if ($excludePatterns.Count -gt 0 -and (Match-AnyWildcard $excludePatterns $cand)) { continue }
            $out.Add($p)
          }
          return $out.ToArray()
        }

        if ($publish) {
          if (-not $publishMulti) {
            Publish-One $target $publishDir
          } else {
            $projectsToPublish = New-Object System.Collections.Generic.List[string]
            foreach ($p in $explicitProjects) { $projectsToPublish.Add($p) }

            $isSolution = $target.ToLowerInvariant().EndsWith('.sln')
            if ($projectsToPublish.Count -eq 0 -and $isSolution) {
              Run "dotnet sln list" {
                $lines = & dotnet sln $target list
                if ($LASTEXITCODE -ne 0) { throw "Falha ao listar projetos do solution: $target" }
                foreach ($line in $lines) {
                  $t = ($line ?? '').Trim()
                  if ($t -match '\.(csproj|fsproj|vbproj)$') {
                    $projectsToPublish.Add($t)
                  }
                }
              }
            }

            if ($projectsToPublish.Count -eq 0 -and -not $isSolution) {
              throw "publish_multi=true requer dotnet_projects (lista de .csproj) ou dotnet_project apontando para um .sln."
            }

            $filtered = Filter-Projects ($projectsToPublish.ToArray())
            if ($filtered.Length -eq 0) {
              throw "publish_multi=true, mas nenhum projeto sobrou apos filtros. Ajuste dotnet_projects(_include/_exclude) ou dotnet_projects."
            }

            foreach ($p in $filtered) {
              $name = [System.IO.Path]::GetFileNameWithoutExtension($p)
              if (-not (IsSet $name)) { throw "Nao foi possivel derivar nome do projeto: $p" }
              $out = Join-Path $publishDir $name
              Publish-One $p $out
            }
          }
        }

        "language_effective=dotnet" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        "build_ran=$($ran.ToString().ToLowerInvariant())" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        "publish_dir=$publishDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        "package_paths_default<<__EOF__`n$publishDir/**`n__EOF__" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
